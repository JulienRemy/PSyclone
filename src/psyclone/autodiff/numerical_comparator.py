# -----------------------------------------------------------------------------
# BSD 3-Clause License
#
# Copyright (c) 2021-2022, Science and Technology Facilities Council.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
# Authors: J. Remy, Inria

"""This file contains a numerical comparator class for the purpose of \
comparing numerical results of programs transformed using `psyclone.autodiff` \
with Tapenade (3.16) in reverse-mode (without `vector`/`multi` mode).
It calls the Jacobian comparator generated by `ComparatorGenerator`, \
which is a Fortran subroutine wrapped using `numpy.f2py`, on iterable \
argument values.
NOTE: this is a work in progress, it hasn't been refactored nor tested yet.
"""


from collections.abc import Iterable
from itertools import product

# NOTE: this is unused but the return of ComparatorGenerator uses it.
import numpy as np

from psyclone.autodiff import ComparatorGenerator


class NumericalComparator(object):
    """This class is a numerical comparator for the purpose of \
    comparing numerical results of programs transformed using `psyclone.autodiff` \
    with Tapenade (3.16) in reverse-mode (without `vector`/`multi` mode).
    It calls the Jacobian comparator generated by `ComparatorGenerator`, \
    which is a Fortran subroutine wrapped using `numpy.f2py`, on iterable \
    argument values.
    NOTE: this is a work in progress, it hasn't been refactored nor tested yet.
    """

    # _fortran_version = "fortran90"

    # TODO: doc this, clean it, refactor it, test it
    @classmethod
    def compare(
        cls,
        tapenade_path,
        file_path,
        routine_name,
        dependent_vars,
        independent_vars,
        argument_values,
        reversal_schedule,
        output_type,
        options=None,
    ):
        if not isinstance(argument_values, dict):
            raise TypeError(
                f"'argument_values' argument should be of type "
                f"'dict' but found '{type(argument_values).__name__}'."
            )
        for var, values in argument_values.items():
            if not isinstance(var, str):
                raise TypeError(
                    f"'argument_values' argument should be of type "
                    f"'dict' with keys of type 'str' but found key "
                    f"'{var}' of type '{type(var).__name__}'."
                )
            if not isinstance(values, Iterable):
                raise TypeError(
                    f"'argument_values' argument should be of type "
                    f"'dict' with values of type 'Iterable' but found value "
                    f"'{values}' of type '{type(values).__name__}'."
                )

        if not isinstance(output_type, str):
            raise TypeError(
                f"'output_type' argument should be of type "
                f"'str' but found '{type(output_type).__name__}'."
            )
        if output_type not in ("Linf_error", "L1_error"):
            raise ValueError(
                f"'output_type' argument should be one of "
                f"'Linf_error' or 'L1_error' but found "
                f"'{output_type}'."
            )

        # Create the comparator subroutine and get the names of the arguments
        comparator, argument_names = ComparatorGenerator.compare(
            tapenade_path,
            file_path,
            routine_name,
            dependent_vars,
            independent_vars,
            reversal_schedule,
            output_type,
            options,
        )

        # Check that the provided arguments match those of the comparator
        if set(argument_names) != set(argument_values.keys()) or (
            len(argument_names) != len(argument_values)
        ):
            raise KeyError(
                "Arguments names returned by "
                "ComparatorGenerator.compare do not match the keys "
                "of the 'argument_values' argument."
            )

        # Sort the argument values in the correct order for the comparator
        sorted_argument_values = []
        for arg_name in argument_names:
            sorted_argument_values.append(argument_values[arg_name])

        # Lists to store the argument values and results
        inputs = []
        outputs = []

        # For each combination of argument values, run the comparator
        for values in product(*sorted_argument_values):
            inputs.append(values)
            output = comparator(*values)
            outputs.append(output)

            #print(
            #    ", ".join(
            #        [f"{arg} = {val}" for arg, val in zip(argument_names, values)]
            #    )
            #)
            #print(f"{output_type}:")
            #print(output)
            #print("===================")

        # Largest error
        max_error = max(outputs)
        associated_values = inputs[outputs.index(max_error)]

        values_string = ", ".join(
            [f"{arg} = {val}" for arg, val in zip(argument_names, associated_values)]
        )

        print(f"Maximum {output_type} was {max_error} for values {values_string}.")

        return max_error, associated_values
        # print(max(outputs))


"""
if __name__ == "__main__":
    from psyclone.autodiff.ad_reversal_schedule import ADSplitReversalSchedule

    schedule = ADSplitReversalSchedule()
    # ComparatorGenerator('./tapenade_3.16/bin/tapenade', 'foo_bar.f90', 'foo', ['f', 'g'], ['x', 'w'], schedule, {'verbose': True})

    argument_values = {"x": [1, 2, 3], "w": [4, 5, 6]}
    NumericalComparator.compare(
        "./tapenade_3.16",
        "foo_bar.f90",
        "foo",
        ["f", "g"],
        ["x", "w"],
        argument_values,
        schedule,
        "L1_error",
        {"verbose": True},
    )
"""
